// generate-metadata.js - Creates all metadata files using image-mapping.json
const fs = require('fs');
const path = require('path');

// --> Load the image mapping generated by upload-images.js
const imageMappingPath = path.join(__dirname, 'image-mapping.json');
if (!fs.existsSync(imageMappingPath)) {
    console.error('âŒ Error: image-mapping.json not found!');
    console.error('Please run "node upload-images.js" first to upload images and generate the mapping.');
    process.exit(1);
}

const imageMappingArray = JSON.parse(fs.readFileSync(imageMappingPath, 'utf-8'));

// --> Create a simple lookup map for: tokenId -> image_url
const imageUrlMap = {};
for (const item of imageMappingArray) {
    imageUrlMap[item.tokenId] = item.url;
}
console.log(`âœ… Loaded image mapping for ${Object.keys(imageUrlMap).length} tokens.\n`);

// --- SPECIAL TOKENS CONFIGURATION ---
const SPECIAL_TOKENS = {
    LEGENDARY: [36, 86, 358, 407], // 4 legendary
    MYTHIC: [428, 503, 585, 541, 575, 597, 587, 890, 880, 926, 838, 958, 988, 998, 725, 577, 365, 441, 392, 567], // 20 mythic
    EPIC: [
        // Original epic tokens
        363, 771, 745, 760, 727, 785, 768, 497, 491, 431, 349, 346, 278, 203, 142, 504, 959,
        // Additional epic tokens
        618, 24, 76, 699, 875, 869, 866, 889, 687, 553, 270, 68, 598
        // Note: 577, 365, 363, 407, 142, 428, 838, 278 are already in LEGENDARY/MYTHIC or already listed above
    ]
};

// Define rarity distribution
const RARITY_TIERS = {
    LEGENDARY: { count: 4, rank: 1 },
    MYTHIC: { count: 20, rank: 2 },
    EPIC: { count: 75, rank: 3 },
    RARE: { count: 200, rank: 4 },
    UNCOMMON: { count: 300, rank: 5 },
    COMMON: { count: 400, rank: 6 }
};

// Fisher-Yates shuffle algorithm
function shuffleArray(array) {
    const arr = [...array];
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

// Create metadata directory
const metadataDir = path.join(__dirname, 'metadata');
if (!fs.existsSync(metadataDir)) {
    fs.mkdirSync(metadataDir, { recursive: true });
}

// Generate metadata for each NFT
function generateAllMetadata() {
    console.log('ğŸ¯ Assigning special tokens to rarities...\n');
    
    // Create a map to store each token's rarity assignment
    const tokenRarityMap = {};
    
    // First, assign LEGENDARY tokens
    SPECIAL_TOKENS.LEGENDARY.forEach(tokenId => {
        tokenRarityMap[tokenId] = {
            rarity: 'LEGENDARY',
            rank: RARITY_TIERS.LEGENDARY.rank
        };
    });
    
    // Then, assign MYTHIC tokens (skip if already assigned)
    SPECIAL_TOKENS.MYTHIC.forEach(tokenId => {
        if (!tokenRarityMap[tokenId]) {
            tokenRarityMap[tokenId] = {
                rarity: 'MYTHIC',
                rank: RARITY_TIERS.MYTHIC.rank
            };
        } else {
            console.log(`âš ï¸  Token #${tokenId} already assigned as ${tokenRarityMap[tokenId].rarity}, skipping MYTHIC assignment`);
        }
    });
    
    // Finally, assign EPIC tokens (skip if already assigned to LEGENDARY or MYTHIC)
    SPECIAL_TOKENS.EPIC.forEach(tokenId => {
        if (!tokenRarityMap[tokenId]) {
            tokenRarityMap[tokenId] = {
                rarity: 'EPIC',
                rank: RARITY_TIERS.EPIC.rank
            };
        } else {
            console.log(`âš ï¸  Token #${tokenId} already assigned as ${tokenRarityMap[tokenId].rarity}, skipping EPIC assignment`);
        }
    });
    
    // Count how many special tokens we've assigned per rarity
    const assignedCounts = {
        LEGENDARY: 0,
        MYTHIC: 0,
        EPIC: 0,
        RARE: 0,
        UNCOMMON: 0,
        COMMON: 0
    };
    
    Object.values(tokenRarityMap).forEach(assignment => {
        assignedCounts[assignment.rarity]++;
    });
    
    // Calculate remaining slots for each rarity
    const remainingSlots = {};
    Object.entries(RARITY_TIERS).forEach(([rarity, config]) => {
        remainingSlots[rarity] = config.count - assignedCounts[rarity];
    });
    
    console.log('\nğŸ“Š Special Token Assignments:');
    console.log(`   LEGENDARY: ${assignedCounts.LEGENDARY} tokens assigned`);
    console.log(`   MYTHIC: ${assignedCounts.MYTHIC} tokens assigned`);
    console.log(`   EPIC: ${assignedCounts.EPIC} tokens assigned\n`);
    
    console.log('ğŸ“Š Remaining Slots to Fill:');
    Object.entries(remainingSlots).forEach(([rarity, count]) => {
        console.log(`   ${rarity}: ${count} remaining`);
    });
    console.log('');
    
    // Get all token IDs that haven't been assigned yet
    const allTokenIds = Array.from({ length: 999 }, (_, i) => i + 1);
    const unassignedTokenIds = allTokenIds.filter(id => !tokenRarityMap[id]);
    
    // Create array of remaining rarity assignments
    const remainingAssignments = [];
    Object.entries(remainingSlots).forEach(([rarity, count]) => {
        for (let i = 0; i < count; i++) {
            remainingAssignments.push({
                rarity: rarity,
                rank: RARITY_TIERS[rarity].rank
            });
        }
    });
    
    // Shuffle the remaining assignments
    const shuffledAssignments = shuffleArray(remainingAssignments);
    
    // Assign remaining tokens
    unassignedTokenIds.forEach((tokenId, index) => {
        tokenRarityMap[tokenId] = shuffledAssignments[index];
    });
    
    let missingImageCount = 0;
    
    // Now create metadata for all tokens
    console.log('ğŸ“ Generating metadata files...\n');
    
    for (let tokenId = 1; tokenId <= 999; tokenId++) {
        const assignment = tokenRarityMap[tokenId];
        
        // Get the correct image URL from the map we loaded
        const imageUrl = imageUrlMap[tokenId];
        
        if (!imageUrl) {
            console.warn(`âš ï¸ Warning: No image URL found in mapping for tokenId: ${tokenId}`);
            missingImageCount++;
        }
        
        const metadata = {
            name: `ZELIA Genesis #${tokenId}`,
            description: `Genesis NFT #${tokenId} of 999.`,
            image: imageUrl || `MISSING_IMAGE_URL_FOR_TOKEN_${tokenId}`, 
            attributes: [
                {
                    trait_type: "Number",
                    value: tokenId
                },
                {
                    trait_type: "Collection",
                    value: "Genesis"
                },
                {
                    trait_type: "Rarity",
                    value: assignment.rarity
                },
                {
                    trait_type: "Rarity Rank",
                    value: assignment.rank
                },
                {
                    trait_type: "Protocol",
                    value: "Zerdinals"
                },
                {
                    trait_type: "Blockchain",
                    value: "Zcash"
                }
            ],
            external_url: `https://eliaos.io/nft/${tokenId}`,
            created_on: "https://eliaos.io"
        };
        
        // Save metadata file
        fs.writeFileSync(
            path.join(metadataDir, `${tokenId}.json`),
            JSON.stringify(metadata, null, 2)
        );
    }
    
    if (missingImageCount > 0) {
        console.error(`\nâŒ CRITICAL: ${missingImageCount} metadata files were generated without a valid image URL!`);
        console.error('Check "image-mapping.json" and re-run "upload-images.js" if necessary.');
    }
    
    // Print distribution summary
    console.log('\nğŸ“Š Final Rarity Distribution:');
    console.log('================================');
    
    const rarityCount = {};
    Object.values(tokenRarityMap).forEach(assignment => {
        rarityCount[assignment.rarity] = (rarityCount[assignment.rarity] || 0) + 1;
    });
    
    Object.entries(rarityCount).forEach(([rarity, count]) => {
        const percentage = ((count / 999) * 100).toFixed(2);
        console.log(`${rarity}: ${count} NFTs (${percentage}%)`);
    });
    
    // Show all special tokens grouped by rarity
    console.log('\nâ­ All Special Token Assignments:');
    console.log('==================================');
    
    ['LEGENDARY', 'MYTHIC', 'EPIC'].forEach(rarity => {
        const tokens = Object.entries(tokenRarityMap)
            .filter(([_, assignment]) => assignment.rarity === rarity)
            .map(([tokenId, _]) => tokenId)
            .sort((a, b) => parseInt(a) - parseInt(b));
        
        console.log(`\n${rarity} (${tokens.length} tokens):`);
        console.log(tokens.join(', '));
    });
    
    console.log('\nâœ… Generated metadata for 999 NFTs with assigned rarities!');
    
    // Save rarity mapping
    saveRarityMapping(tokenRarityMap);
}

// Save rarity mapping for reference
function saveRarityMapping(tokenRarityMap) {
    fs.writeFileSync(
        path.join(__dirname, 'rarity-mapping.json'),
        JSON.stringify(tokenRarityMap, null, 2)
    );
    
    console.log('ğŸ“ Saved rarity mapping to rarity-mapping.json');
}

// Run the generator
if (require.main === module) {
    generateAllMetadata();
}

module.exports = { generateAllMetadata };
